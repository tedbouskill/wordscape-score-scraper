{
	//
	// Place your workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
	//
	// Placeholders with the same ids are connected.
	//
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Main": {
		"prefix": "python_main",
		"body": [
			"def main():",
			"    ${1:pass}",
			"",
			"if __name__ == '__main__':",
			"    main()"
		],
		"description": "Main function"
	},
	"ScopedResourceClass": {
		"prefix": "scopedresource",
		"body": [
			"class ScopedResource:",
			"    def __init__(self, ${1:resource_name}):",
			"        \"\"\"",
			"        Initialize the class with the given resource name.",
			"        \"\"\"",
			"        self.resource_name = ${1:resource_name}",
			"        self.resource = None",
			"        print(f\"[INIT] ScopedResource initialized with resource: {${1:resource_name}}\")",
			"",
			"    def __enter__(self):",
			"        \"\"\"",
			"        Code to execute when entering a 'with' block.",
			"        Here, we simulate acquiring a resource.",
			"        \"\"\"",
			"        self.resource = f\"Acquired {self.resource_name}\"",
			"        print(f\"[ENTER] Resource '{self.resource_name}' is ready for use.\")",
			"        return self  # Return self to access the resource in the 'with' block",
			"",
			"    def __exit__(self, exc_type, exc_value, traceback):",
			"        \"\"\"",
			"        Code to execute when exiting a 'with' block.",
			"        Here, we release the resource.",
			"        \"\"\"",
			"        print(f\"[EXIT] Cleaning up resource: {self.resource_name}\")",
			"        self.resource = None  # Clear resource",
			"        if exc_type:",
			"            print(f\"[ERROR] An error occurred: {exc_type}, {exc_value}\")",
			"        return False  # Propagate exceptions if they occurred",
			"",
			"    def perform_task(self):",
			"        \"\"\"",
			"        Simulate a task using the resource.",
			"        \"\"\"",
			"        if self.resource:",
			"            print(f\"[TASK] Using resource: {self.resource}\")",
			"        else:",
			"            print(\"[TASK] Resource is not available.\")",
			"",
			"# Example usage",
			"if __name__ == \"__main__\":",
			"    with ScopedResource(\"SampleResource\") as resource:",
			"        resource.perform_task()",
			"    print(\"[DONE] Resource is now out of scope.\")"
		],
		"description": "ScopedResource class with context management methods (__enter__, __exit__)."
	},
	"SingletonClassWithCleanup": {
		"prefix": "singletonclass",
		"body": [
			"class ${1:SingletonClass}:",
			"    _instance = None",
			"",
			"    def __new__(cls, *args, **kwargs):",
			"        \"\"\"",
			"        Ensures only one instance of the class is created.",
			"        \"\"\"",
			"        if cls._instance is None:",
			"            cls._instance = super().__new__(cls)",
			"            print(f\"[NEW] Instance of {cls.__name__} created.\")",
			"        return cls._instance",
			"",
			"    def __init__(self, ${2:arg1}):",
			"        \"\"\"",
			"        Initialize the singleton instance.",
			"        \"\"\"",
			"        if not hasattr(self, '_initialized'):",
			"            self.${2:arg1} = ${2:arg1}",
			"            self._initialized = True",
			"            print(f\"[INIT] Singleton instance initialized with: {${2:arg1}}.\")",
			"",
			"    @classmethod",
			"    def cleanup(cls):",
			"        \"\"\"",
			"        Cleanup method to reset or release resources.",
			"        \"\"\"",
			"        if cls._instance is not None:",
			"            print(f\"[CLEANUP] Cleaning up singleton instance of {cls.__name__}.\")",
			"            cls._instance = None",
			"",
			"    def __del__(self):",
			"        \"\"\"",
			"        Destructor to handle cleanup automatically if the singleton is deleted.",
			"        \"\"\"",
			"        print(f\"[DEL] Singleton instance of {self.__class__.__name__} is being destroyed.\")",
			"",
			"    def some_method(self):",
			"        \"\"\"",
			"        Example method to demonstrate singleton usage.",
			"        \"\"\"",
			"        print(f\"[METHOD] Using singleton with arg1: {self.${2:arg1}}.\")",
			"",
			"# Example usage",
			"if __name__ == \"__main__\":",
			"    instance1 = ${1:SingletonClass}(\"Value1\")",
			"    instance1.some_method()",
			"",
			"    print(\"[INFO] Cleaning up the singleton...\")",
			"    ${1:SingletonClass}.cleanup()",
			"",
			"    print(\"[INFO] Recreating the singleton...\")",
			"    instance2 = ${1:SingletonClass}(\"Value2\")",
			"    instance2.some_method()"
		],
		"description": "Python singleton class with cleanup and destructor methods."
	},
	"ThreadSafeSingletonClassWithCleanup": {
		"prefix": "threadedsingleton",
		"body": [
			"import threading",
			"",
			"class ${1:ThreadSafeSingleton}:",
			"    _instance = None",
			"    _lock = threading.Lock()  # Lock object to ensure thread safety",
			"",
			"    def __new__(cls, *args, **kwargs):",
			"        \"\"\"",
			"        Ensures only one instance of the class is created, even in a multithreaded environment.",
			"        \"\"\"",
			"        if cls._instance is None:",
			"            with cls._lock:",
			"                if cls._instance is None:  # Double-checked locking",
			"                    cls._instance = super().__new__(cls)",
			"                    print(f\"[NEW] Thread-safe instance of {cls.__name__} created.\")",
			"        return cls._instance",
			"",
			"    def __init__(self, ${2:arg1}):",
			"        \"\"\"",
			"        Initialize the singleton instance.",
			"        \"\"\"",
			"        if not hasattr(self, '_initialized'):",
			"            self.${2:arg1} = ${2:arg1}",
			"            self._initialized = True",
			"            print(f\"[INIT] Singleton instance initialized with: {${2:arg1}}.\")",
			"",
			"    @classmethod",
			"    def cleanup(cls):",
			"        \"\"\"",
			"        Cleanup method to reset or release resources.",
			"        \"\"\"",
			"        with cls._lock:",
			"            if cls._instance is not None:",
			"                print(f\"[CLEANUP] Cleaning up singleton instance of {cls.__name__}.\")",
			"                cls._instance = None",
			"",
			"    def __del__(self):",
			"        \"\"\"",
			"        Destructor to handle cleanup automatically if the singleton is deleted.",
			"        \"\"\"",
			"        print(f\"[DEL] Singleton instance of {self.__class__.__name__} is being destroyed.\")",
			"",
			"    def some_method(self):",
			"        \"\"\"",
			"        Example method to demonstrate singleton usage.",
			"        \"\"\"",
			"        print(f\"[METHOD] Using thread-safe singleton with arg1: {self.${2:arg1}}.\")",
			"",
			"# Example usage",
			"if __name__ == \"__main__\":",
			"    def create_instance(value):",
			"        instance = ${1:ThreadSafeSingleton}(value)",
			"        instance.some_method()",
			"",
			"    threads = [threading.Thread(target=create_instance, args=(f\"Value{i}\",)) for i in range(5)]",
			"",
			"    for thread in threads:",
			"        thread.start()",
			"",
			"    for thread in threads:",
			"        thread.join()",
			"",
			"    print(\"[INFO] Cleaning up the thread-safe singleton...\")",
			"    ${1:ThreadSafeSingleton}.cleanup()",
			"",
			"    print(\"[DONE] All threads completed.\")"
		],
		"description": "Thread-safe Python singleton class with cleanup and destructor methods."
	}
}

